= What does it mean "to be secure" in cryptography?
:stem: 
:toc: auto
:toc-title: Table of content
:source-highlighter: highlight.js

link:../../index.html[Back to main page]

[%breakable]
== Introduction

I've been keep asking this question to myself for a long time. What does it mean for an encryption scheme to be secure? 

First, let's define a few terms and, at the same time, narrow down the scope of the article. 

Encryption scheme is a collection of three algorithms:

. Key generation algorithm (KeyGen)
. Encryption algorithm (Enc)
. Decryption algorithm (Dec)

Every encryption scheme must satisfy the "correctness" property. That is, for every key `k` generated by the KeyGen algorithm, and every message `m`, it must be the case that:
```
Dec(k, Enc(k, m)) = m
```

Example of encryption scheme is AES-256.

Now, let's define the term "secure". Security of information can be described in terms of CIA triad:

. Confidentiality
. Integrity
. Availability

In this article, I will focus *only on the confidentiality aspect* of encryption schemes. 
So, the goal is to keep information confidential.

Moreover, I don't consider side-channel attacks, such as timing attacks, power analysis, etc. I will focus on the security of the encryption scheme itself.


[%breakable]
== Perfect security

The most common way to define security of an encryption scheme is to employ the concept of indistinguishability. Intuitively, the security of an encryption scheme means that an adversary can not learn anything about the plaintext by observing only the ciphertext. Alternatively:

. ciphertext should look as a piece of junk to any unauthorized party. 
. a probability that a given ciphertext represents any message `m1`, should be exactly the same as a probability that it represents any other, different message `m2`.

The last point, can be expressed more formally as follows:
```
Pr[Enc(k, m1) = c] = Pr[Enc(k, m2) = c]
```

=== Example 1 (one-time pad)

Let's consider a one-time pad encryption scheme (very simple scheme, described for example here: link:../posts/4/index.html[Deniable encryption with one-time pad]). Additionally, for simplicity, let's assume that we operate on 3-bit messages. 

Our example messages are (we can choose any messages):
```
m1 = 101
m2 = 010
```

The key space is the set of all possible 3-bit keys:
|===
| Key | P(Key)

| 000 | 1/8
| 001 | 1/8
| 010 | 1/8
| 100 | 1/8
| 011 | 1/8
| 101 | 1/8
| 110 | 1/8
| 111 | 1/8
|===

**Important:** Please note that our key is a random variable uniformly distributed over the key space. The probability to select any key is the same - 1/8. In other words, they key is chosen uniformly/randomly.

|===
| Key | P(Key) | c1 = Enc(k, m1) | P(c1) | c2 = Enc(k, m2) | P(c2)

| 000 | 1/8 | 101 | 1/8 | 010 | 1/8
| 001 | 1/8 | 100 | 1/8 | 011 | 1/8
| 010 | 1/8 | 111 | 1/8 | 000 | 1/8
| 100 | 1/8 | 001 | 1/8 | 110 | 1/8
| 011 | 1/8 | 110 | 1/8 | 001 | 1/8
| 101 | 1/8 | 011 | 1/8 | 101 | 1/8
| 110 | 1/8 | 000 | 1/8 | 111 | 1/8
| 111 | 1/8 | 010 | 1/8 | 100 | 1/8
|===

Now, let's assume an adversary intercepted some ciphertext, can be for example `c3 = 111`. What is a probability that the message was `m1` or `m2`?
```
Pr[Enc(k, m1) = c3] = Pr[Enc(k, m2) = c3] = 1/8
```

In other words, our adversary can't distinguish between `m1` and `m2` based on the ciphertext `c3`. 

*This is what we call a perfect security.*

[%breakable]
=== Example 2 (non-uniform key distribution)

Let's modify our previous example and think, for a moment, about a scenario when a key distribution is not uniform. All other parameters remain the same.

|===
| Key | P(Key) | c1 = Enc(k, m1) | P(c1) | c2 = Enc(k, m2) | P(c2)

| 000 | 1/8 | 101 | 1/8 | 010 | 1/8
| 001 | 1/8 | 100 | 1/8 | 011 | 1/8
| 010 | 1/4 | 111 | 1/8 | 000 | 1/8
| 100 | 1/8 | 001 | 1/8 | 110 | 1/8
| 011 | 1/8 | 110 | 1/8 | 001 | 1/8
| 101 | 1/4 | 011 | 1/8 | 101 | 1/8
| 110 | 0 | 000 | 1/8 | 111 | 1/8
| 111 | 0 | 010 | 1/8 | 100 | 1/8
|===

Above, there is some non-uniform key distribution. Obviously:
```
Pr[Enc(k, m1) = c3] =  1/4 
Pr[Enc(k, m2) = c3] = 0

Pr[Enc(k, m1) = c3]  != Pr[Enc(k, m2) = c3]
```

A few points to be made. 

Firstly, adversary, when confronted with the ciphertext `c3`, can simply choose the keys with highest probability and by doing this increase his chance of correct guess (1/4 vs 1/8 vs 0). The more non-uniform the key distribution is, the easier it is for the adversary to guess the message.

Secondly, let's calculate advantage of our adversary. What is advantage? We can define it as follows:
```
Adv. = | Pr[Dec(k3, c3) = m3] - 1/8 |
```
where `k3` is a key chosen by the adversary, `c3` is a ciphertext, and `m3` is a message that adversary tries to recover.

If the key is sampled uniformly, the chances of the adversary to guess the message are 1/8. If the key is not sampled uniformly, the chances are higher. In our case, the advantage is a difference between the probability that adversary finds proper message and 1/8.

So:
```
Adv. in case of uniform distribution = | 1/8 - 1/8 | = 0 -> perfect security
Adv. in case of our example distribution = | 1/4 - 1/8 | = 1/4
```

Please note that the advantage depends on concrete strategy taken by adversary. In our case the strategy is very simple - always take a key with the highest probability (1/4). 

[%breakable]
== Practical security
