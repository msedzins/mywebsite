= What does it mean to be "secure" in cryptography?
:stem: 
:toc: auto
:toc-title: Table of content
:source-highlighter: highlight.js

link:../../index.html[Back to main page]

[%breakable]
== Introduction

I've been asking myself this question for a long time. What does it mean for an encryption scheme to be secure? 

First, let's define a few terms and, at the same time, narrow down the scope of the article. 

Symmetric-key encryption scheme is a collection of three algorithms:

. Key generation algorithm (KeyGen)
. Encryption algorithm (Enc)
. Decryption algorithm (Dec)

Every encryption scheme must satisfy the "correctness" property. That is, for every key `k` generated by the KeyGen algorithm, and every message `m`, it must be the case that:
```
Dec(k, Enc(k, m)) = m
```

Example of encryption scheme is AES-256.

Now, let's define the term "secure". Security of information can be described in terms of CIA triad:

. Confidentiality
. Integrity
. Availability

In this article, I will focus *only on the confidentiality aspect* of encryption schemes. 
So, the goal is to keep information confidential.

Moreover, I don't consider side-channel attacks, such as timing attacks, power analysis, etc. I will focus on the security of the encryption scheme itself.


[%breakable]
== Perfect security

The most common way to define security of an encryption scheme is to employ the concept of indistinguishability. Intuitively, the security of an encryption scheme means that an adversary can not learn anything about the plaintext by observing only the ciphertext. Alternatively:

. ciphertext should look as a piece of junk to any unauthorized party. 
. a probability that a given ciphertext represents any message `m1`, should be exactly the same as a probability that it represents any other, different message `m2`.

The last point, can be expressed more formally as follows:
```
Pr[Enc(k, m1) = c] = Pr[Enc(k, m2) = c]
```

=== Example 1 (one-time pad)

Let's consider a one-time pad encryption scheme (very simple scheme, described for example here: link:../posts/4/index.html[Deniable encryption with one-time pad]). Additionally, for simplicity, let's assume that we operate on 3-bit messages. 

Example messages are (any messages can be chosen):
```
m1 = 101
m2 = 010
```

The key space is the set of all possible 3-bit keys:
|===
| Key | P(Key)

| 000 | 1/8
| 001 | 1/8
| 010 | 1/8
| 100 | 1/8
| 011 | 1/8
| 101 | 1/8
| 110 | 1/8
| 111 | 1/8
|===

**Important:** Please note that our key is a random variable uniformly distributed over the key space. The probability to select any key is the same - 1/8. In other words, they key is chosen uniformly/randomly.

Below, there is a table with all possible keys, ciphertexts with respect to the messages `m1` and `m2`, and their probabilities:
|===
| Key | P(Key) | c1 = Enc(k, m1) | P(c1) | c2 = Enc(k, m2) | P(c2)

| 000 | 1/8 | 101 | 1/8 | 010 | 1/8
| 001 | 1/8 | 100 | 1/8 | 011 | 1/8
| 010 | 1/8 | 111 | 1/8 | 000 | 1/8
| 100 | 1/8 | 001 | 1/8 | 110 | 1/8
| 011 | 1/8 | 110 | 1/8 | 001 | 1/8
| 101 | 1/8 | 011 | 1/8 | 101 | 1/8
| 110 | 1/8 | 000 | 1/8 | 111 | 1/8
| 111 | 1/8 | 010 | 1/8 | 100 | 1/8
|===

Now, let's assume an adversary intercepted some ciphertext, can be for example `c3 = 111`. What is a probability that the message was `m1` or `m2`? From the table above, it can be observed that:
```
Pr[Enc(k, m1) = c3] = Pr[Enc(k, m2) = c3] = 1/8
```

In other words, our adversary can't distinguish between `m1` and `m2` based on the ciphertext `c3`. 

*This property is called a perfect security.*

[%breakable]
=== Example 2 (non-uniform key distribution)

Let's modify our previous example and think, for a moment, about a scenario when a key distribution is not uniform (common situation as there is no perfect random generator). All other parameters remain the same.

|===
| Key | P(Key) | c1 = Enc(k, m1) | P(c1) | c2 = Enc(k, m2) | P(c2)

| 000 | 1/8 | 101 | 1/8 | 010 | 1/8
| 001 | 1/8 | 100 | 1/8 | 011 | 1/8
| 010 | 1/4 | 111 | 1/8 | 000 | 1/8
| 100 | 1/8 | 001 | 1/8 | 110 | 1/8
| 011 | 1/8 | 110 | 1/8 | 001 | 1/8
| 101 | 1/4 | 011 | 1/8 | 101 | 1/8
| 110 | 0 | 000 | 1/8 | 111 | 1/8
| 111 | 0 | 010 | 1/8 | 100 | 1/8
|===

Above, there is some non-uniform key distribution. Obviously:
```
Pr[Enc(k, m1) = c3] =  1/4 
Pr[Enc(k, m2) = c3] = 0

Pr[Enc(k, m1) = c3]  != Pr[Enc(k, m2) = c3]
```

A few points to be made. 

Firstly, adversary, when confronted with the ciphertext `c3`, can simply choose the keys with highest probability and by doing this increase his chance of correct guess (1/4 vs 1/8 vs 0). The more non-uniform the key distribution is, the easier it is for the adversary to guess the message.

Secondly, let's calculate an advantage of our adversary, which can be defined as follows:
```
Adv = | Pr[Dec(k3, c3) = m3] - 1/8 |
```
where `k3` is a key chosen by the adversary, `c3` is a ciphertext, and `m3` is a message that the adversary tries to recover.

If the key is sampled uniformly, the chances of the adversary to guess the message are 1/8 (this is what's called a brute-force attack). If the key is not sampled uniformly, the chances are higher. In our case, the advantage is a difference between the probability that the adversary finds proper message and 1/8.

So:
```
Adv in case of uniform distribution = | 1/8 - 1/8 | = 0 -> perfect security
Adv in case of our example distribution = | 1/4 - 1/8 | = 1/4 -> is this even secure...? 
```

Please note that:

. the advantage depends on the concrete strategy taken by the adversary. In our case the strategy is very simple - always take a key with the highest probability (1/4). 
. the advantage can be defined in different ways. For example, one could calculate the advantage of distinguishing between `m1` and `m2` (which is again zero, in case of perfect security).
. the presented encryption scheme is not secure because the advantage is not negligible (what "negligible" means is covered in the next section).

[%breakable]
== Practical (aka semantic) security

Perfect security is a very strong property. But it's hard to achieve in practice. For example, one-time pad is perfectly secure, but it's not practical. 

One of the reasons is that the key must be as long as the message (example proof - [2]). Secondly, the key must be random and never reused.

The good news is that one can relax the definition of security and still have a useful encryption scheme. In real life, what is required is to make sure that no *efficient* adversary can break encryption with *non-negligible* probability.

It can be expressed as follows (using expression i've already introduced in the previous section):
```
Pr[Enc(k, m1) = c] ≈ Pr[Enc(k, m2) = c]
```
Please note that the "=" sign was replaced with "≈".

Transforming the above expression, we get:
```
| Pr[Enc(k, m1) = c] - Pr[Enc(k, m2) = c] | =  ε
```

`ε` represents the advantage of the adversary. In case of perfect security it is 0, but for semantic security it is enough for `ε` to be negligible:
```
| Pr[Enc(k, m1) = c] - Pr[Enc(k, m2) = c] |   ≤ ε
```


[%breakable]
=== Efficient adversary

First, let's define what an efficient adversary is. From practical point of view, an efficient adversary is a program that can run in a reasonable time (like days/months and not 100 years). Below, there is more formal definition.


Definition 1:: A program runs in polynomial time if there exists a polynomial `p` such that the program halts in at most `p(n)` steps on any input of length `n`.

Definition 2:: An adversary is efficient if it runs in polynomial time.

Two points to made:

. Polynomial time is not a perfect measure of efficiency. For example, a program that runs in `n^1000` steps is polynomial, but might not be efficient from practical point of view. On the other hand, program with time complexity `O(n^loglogloglog(n))` is not polynomial, hence is considered not efficient. Despite that, polynomial time is a good practical approximation of efficiency, excluding some corner cases.
. Definition of efficiency is deterministic in our case (for simplification). More accurate would be to assume that algorithm behind the adversary is probabilistic, which means it can exceed polynomial time, but with very low probability.

[%breakable]
=== Negligible function

Definition 3:: A function `f` is negligible if for every polynomial `p`, we have:
[stem]
++++
\lim_{n \to \infty} p(n)f(n) = 0
++++

In other words, a function is negligible if it decreases faster than any polynomial.

Let's think for a moment, what does it mean in practice: assuming there is an efficient adversary (which runs in polynomial time `O(p(n))`, and encryption scheme for which advantage is a negligible function `f(n)`, as we increase parameter `n` (called security parameter), there is no chance for p(n) to catch up with f(n)!

It's enough to select a proper security parameter `n` to make sure that the adversary can't break the encryption scheme with non-negligible probability.

=== Example

The function `f(n) = 1/2^n` is negligible because:
[stem]
++++
\lim_{n \to \infty} n^c / (1/2^n) = 0
++++

where `c` is any constant.


The function `f(n) = n^100` is not negligible because:
[stem]
++++
\lim_{n \to \infty} n^c n^100 != 0
++++

for any constant `c≥100`.

Here is a simple diagram that shows how `n^c / (1/2^n)` behaves for different values of `c∈{2,3,4,5}`:

image::diagram.png[diagram]

As can be seen, the function `1/2^n` decreases much faster than the polynomial function and finally the product of two functions approaches zero.

[%breakable]
== Summary

In most real-life scenarios, perfect security is not achievable. Instead, one can aim for semantic security, which is a weaker property, but still useful and used in practice.

[%breakable]
== References

Below, please find a list of references that I used to write this article. I can highly recommend them to anyone interested in the topic.

. "The Joy of Cryptography", Mike Rosulek, 2021
. "A Graduate Course in Applied Cryptography", Dan Boneh and Victor Shoup, 2023